#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
procesa_datos_propiedades.py

Script para procesar los datos crudos extraídos y generar el repositorio
completo con todos los campos necesarios.
"""

import os
import json
from datetime import datetime
from bs4 import BeautifulSoup
import re
import shutil

# Constantes y rutas
CARPETA_DATOS_CRUDOS = "resultados/datos_crudos"
ARCHIVO_SALIDA = "resultados/propiedades_estructuradas.json"
ARCHIVO_BACKUP = "resultados/propiedades_estructuradas.json.bak"
ARCHIVO_REPOSITORIO = "resultados/repositorio_propiedades.json"

def extraer_datos_html(contenido_json):
    """Extrae datos del contenido JSON que contiene HTML"""
    try:
        # Parsear el JSON que contiene el HTML
        datos_json = json.loads(contenido_json)
        html_content = datos_json.get('html', '')
        
        # Crear el objeto BeautifulSoup
        soup = BeautifulSoup(html_content, 'html.parser')
        
        # Extraer datos
        datos = {
            "descripcion_original": "",
            "ubicacion": {
                "colonia": "",
                "calle": "",
                "estado": "Morelos",
                "ciudad": "Cuernavaca",
                "zona": "",
                "ubicacion_referencia": "",
                "puntos_interes": []
            },
            "propiedad": {
                "tipo_propiedad": "No especificado",
                "precio": "",
                "mantenimiento": {
                    "cuota_mantenimiento": "",
                    "periodo": "",
                    "incluye": []
                },
                "tipo_operacion": "No especificado",
                "moneda": "MXN"
            },
            "descripcion": {
                "caracteristicas": {
                    "recamaras": 0,
                    "banos": 0,
                    "medio_bano": 0,
                    "niveles": 1,
                    "estacionamientos": 0,
                    "edad": "",
                    "recamara_planta_baja": False,
                    "cisterna": {
                        "tiene": False,
                        "capacidad": ""
                    },
                    "superficie_m2": 0,
                    "construccion_m2": 0
                },
                "amenidades": {
                    "seguridad": False,
                    "alberca": False,
                    "patio": False,
                    "bodega": False,
                    "terraza": False,
                    "jardin": False,
                    "estudio": False,
                    "roof_garden": False
                },
                "legal": {
                    "escrituras": False,
                    "cesion_derechos": False,
                    "formas_de_pago": []
                }
            }
        }

        # Extraer descripción original
        descripcion_div = soup.find('div', {'data-testid': 'marketplace-listing-item-description'})
        if descripcion_div:
            datos['descripcion_original'] = descripcion_div.get_text(strip=True)
            desc_lower = datos['descripcion_original'].lower()

            # Extraer tipo de propiedad
            tipos_propiedad = {
                'casa': ['casa sola', 'casa en condominio', 'casa'],
                'departamento': ['departamento', 'depto', 'dpto'],
                'terreno': ['terreno', 'lote'],
                'local': ['local comercial', 'local'],
                'oficina': ['oficina'],
                'bodega comercial': ['bodega comercial', 'bodega']
            }

            for tipo, palabras in tipos_propiedad.items():
                for palabra in palabras:
                    if palabra in desc_lower:
                        datos['propiedad']['tipo_propiedad'] = tipo
                        break
                if datos['propiedad']['tipo_propiedad'] != "No especificado":
                    break

            # Extraer tipo de operación
            if 'venta' in desc_lower or 'se vende' in desc_lower:
                datos['propiedad']['tipo_operacion'] = 'venta'
            elif 'renta' in desc_lower or 'se renta' in desc_lower:
                datos['propiedad']['tipo_operacion'] = 'renta'

            # Extraer precio
            precio_pattern = r'\$[\d,]+(?:\.?\d*)?(?:\s*(?:mil|millones|mdp))?'
            precio_match = re.search(precio_pattern, datos['descripcion_original'])
            if precio_match:
                datos['propiedad']['precio'] = precio_match.group()

            # Extraer características
            patrones = {
                'recamaras': [r'(\d+)\s*(?:rec[aá]mar|recam|rec|habitaci|cuart)',
                             r'(?:rec[aá]mar|recam|rec|habitaci|cuart)[^\d]*(\d+)'],
                'banos': [r'(\d+(?:\.\d+)?)\s*(?:ba[ñn]|wc)',
                         r'(?:ba[ñn]|wc)[^\d]*(\d+(?:\.\d+)?)'],
                'estacionamientos': [r'(\d+)\s*(?:estacionamiento|cochera|lugar|auto)',
                                   r'(?:estacionamiento|cochera|lugar|auto)[^\d]*(\d+)'],
                'superficie_m2': [r'(\d+)\s*(?:m2|metros|mt2)',
                                r'(?:m2|metros|mt2)[^\d]*(\d+)'],
                'construccion_m2': [r'(\d+)\s*(?:m2|metros|mt2)\s*(?:de\s*)?cons',
                                  r'cons[^\d]*(\d+)\s*(?:m2|metros|mt2)']
            }

            for campo, patrones_campo in patrones.items():
                for patron in patrones_campo:
                    match = re.search(patron, desc_lower)
                    if match:
                        valor = float(match.group(1))
                        if campo == 'banos':
                            parte_entera = int(valor)
                            parte_decimal = valor - parte_entera
                            datos['descripcion']['caracteristicas']['banos'] = parte_entera
                            if parte_decimal > 0:
                                datos['descripcion']['caracteristicas']['medio_bano'] = 1
                        else:
                            datos['descripcion']['caracteristicas'][campo] = int(valor)
                        break

            # Extraer amenidades
            amenidades = {
                'seguridad': ['vigilancia', 'seguridad', 'caseta'],
                'alberca': ['alberca', 'piscina'],
                'patio': ['patio'],
                'bodega': ['bodega'],
                'terraza': ['terraza'],
                'jardin': ['jardin', 'jardín'],
                'estudio': ['estudio', 'oficina'],
                'roof_garden': ['roof garden', 'roofgarden', 'terraza']
            }

            for amenidad, palabras in amenidades.items():
                for palabra in palabras:
                    if palabra in desc_lower:
                        datos['descripcion']['amenidades'][amenidad] = True
                        break

            # Extraer información legal
            legal = {
                'escrituras': ['escrituras', 'escriturada'],
                'cesion_derechos': ['cesión de derechos', 'cesion de derechos']
            }

            for campo, palabras in legal.items():
                for palabra in palabras:
                    if palabra in desc_lower:
                        datos['descripcion']['legal'][campo] = True
                        break

            # Extraer formas de pago
            formas_pago = ['contado', 'crédito', 'credito', 'infonavit', 'fovissste', 'bancario']
            for forma in formas_pago:
                if forma in desc_lower:
                    datos['descripcion']['legal']['formas_de_pago'].append(forma)

            # Extraer ubicación
            ubicacion_patterns = {
                'colonia': [r'col(?:onia)?\.?\s+([^,\.]+)', r'fracc(?:ionamiento)?\.?\s+([^,\.]+)'],
                'calle': [r'calle\s+([^,\.]+)'],
                'zona': [r'zona\s+([^,\.]+)']
            }

            for campo, patterns in ubicacion_patterns.items():
                for pattern in patterns:
                    if match := re.search(pattern, desc_lower):
                        datos['ubicacion'][campo] = match.group(1).strip().title()
                        break

        return datos

    except Exception as e:
        print(f"Error al procesar HTML: {str(e)}")
        return None

def procesar_datos_crudos():
    """
    Procesa los datos crudos del archivo JSON y genera un nuevo archivo con los datos estructurados.
    """
    try:
        # Crear directorio de resultados si no existe
        os.makedirs('resultados', exist_ok=True)
        
        # Crear copia de seguridad si existe el archivo de salida
        if os.path.exists(ARCHIVO_SALIDA):
            shutil.copy2(ARCHIVO_SALIDA, ARCHIVO_BACKUP)
            print(f"Se ha creado una copia de seguridad en {ARCHIVO_BACKUP}")
        
        # Leer datos crudos
        with open(ARCHIVO_REPOSITORIO, 'r', encoding='utf-8') as f:
            datos_crudos = json.load(f)
        
        # Procesar cada propiedad
        propiedades_procesadas = []
        total_propiedades = len(datos_crudos)
        propiedades_ok = 0
        propiedades_error = 0
        
        for i, (id_propiedad, propiedad) in enumerate(datos_crudos.items(), 1):
            try:
                # Extraer descripción
                descripcion = propiedad.get('descripcion', '')
                if isinstance(descripcion, dict):
                    descripcion = descripcion.get('texto_limpio', '') or descripcion.get('texto_original', '')
                
                # Preparar datos para procesar
                datos_propiedad = {
                    'id': id_propiedad,
                    'link': propiedad.get('link', ''),
                    'descripcion': descripcion,
                    'ubicacion': {
                        'colonia': '',
                        'calle': '',
                        'estado': 'Morelos',
                        'ciudad': propiedad.get('ciudad', 'Cuernavaca'),
                        'referencias': '',
                        'zona': ''
                    },
                    'fecha_extraccion': propiedad.get('fecha_extraccion', datetime.now().isoformat())
                }
                
                # Procesar la propiedad
                propiedad_procesada = procesar_texto(datos_propiedad['descripcion'], datos_propiedad)
                
                # Agregar datos adicionales del JSON original
                propiedad_procesada['titulo'] = propiedad.get('titulo', '')
                propiedad_procesada['vendedor'] = {
                    'nombre': propiedad.get('vendedor', ''),
                    'link': propiedad.get('link_vendedor', '')
                }
                propiedad_procesada['imagen_portada'] = propiedad.get('imagen_portada', '')
                propiedad_procesada['tipo_operacion'] = propiedad.get('tipo_operacion', 'Desconocido')
                
                # Procesar el precio directamente del repositorio
                precio_original = propiedad.get('precio', '')
                if precio_original:
                    try:
                        # Limpiar el precio
                        precio_limpio = str(precio_original).replace('$', '').replace(' ', '').strip()
                        
                        # Convertir a valor numérico
                        if precio_limpio.count('.') > 1:  # Formato con puntos como separadores
                            valor = float(''.join(precio_limpio.split('.')))
                        elif precio_limpio.count(',') > 1:  # Formato con comas como separadores
                            valor = float(''.join(precio_limpio.split(',')))
                        else:  # Otros formatos
                            valor = float(precio_limpio.replace(',', '.'))
                        
                        propiedad_procesada['propiedad']['precio'] = {
                            "valor": valor,
                            "formato": precio_original,
                            "moneda": "MXN",
                            "confianza": 1.0,
                            "mensaje": "Precio del repositorio original",
                            "fuente": "repositorio"
                        }
                    except Exception as e:
                        print(f"Error procesando precio original '{precio_original}': {str(e)}")
                
                propiedades_procesadas.append(propiedad_procesada)
                propiedades_ok += 1
                
                # Mostrar progreso cada 10 propiedades
                if i % 10 == 0:
                    print(f"Progreso: {i}/{total_propiedades} [OK: {propiedades_ok}, Errores: {propiedades_error}]")
                
            except Exception as e:
                print(f"Error al procesar propiedad {id_propiedad}: {str(e)}")
                propiedades_error += 1
        
        # Guardar resultados
        resultados = {
            "propiedades": propiedades_procesadas,
            "metadata": {
                "total_propiedades": total_propiedades,
                "procesadas_ok": propiedades_ok,
                "procesadas_error": propiedades_error,
                "fecha_procesamiento": datetime.now().isoformat()
            }
        }
        
        with open(ARCHIVO_SALIDA, 'w', encoding='utf-8') as f:
            json.dump(resultados, f, ensure_ascii=False, indent=2)
        
        print(f"\nProcesamiento completado:")
        print(f"Total propiedades: {total_propiedades}")
        print(f"Procesadas exitosamente: {propiedades_ok}")
        print(f"Con errores: {propiedades_error}")
        print(f"Resultados guardados en: {ARCHIVO_SALIDA}")
        
    except Exception as e:
        print(f"Error al procesar el archivo: {str(e)}")

def extraer_zona(texto):
    """
    Extrae la zona o colonia mencionada en el texto.
    """
    texto = normalizar_texto(texto)
    
    # Patrones para detectar zonas/colonias
    patrones = [
        r'(?:en|ubicad[oa] en)\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:cerca|junto|proximo|a\s+(?:\d+\s+)?min(?:utos)?|sobre|por|entre|cuernavaca|morelos))',
        r'col(?:onia)?\.?\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:cerca|junto|proximo|a\s+(?:\d+\s+)?min(?:utos)?|sobre|por|entre|cuernavaca|morelos))',
        r'fracc(?:ionamiento)?\.?\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:cerca|junto|proximo|a\s+(?:\d+\s+)?min(?:utos)?|sobre|por|entre|cuernavaca|morelos))',
        r'unidad\s+hab(?:itacional)?\.?\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:cerca|junto|proximo|a\s+(?:\d+\s+)?min(?:utos)?|sobre|por|entre|cuernavaca|morelos))',
        r'barrio\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:cerca|junto|proximo|a\s+(?:\d+\s+)?min(?:utos)?|sobre|por|entre|cuernavaca|morelos))',
        r'residencial\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:cerca|junto|proximo|a\s+(?:\d+\s+)?min(?:utos)?|sobre|por|entre|cuernavaca|morelos))'
    ]
    
    # Palabras que no deben ser parte del nombre de la zona
    palabras_invalidas = [
        'venta', 'renta', 'precio', 'cerca', 'junto', 'proximo', 'minutos',
        'sobre', 'entre', 'casa', 'depto', 'departamento', 'terreno',
        'infonavit', 'credito', 'banco', 'recurso', 'propio', 'acepto',
        'aceptamos', 'contado', 'sala', 'comedor', 'cocina', 'recamara',
        'recamaras', 'bano', 'banos', 'estacionamiento', 'garage',
        'cuernavaca', 'morelos'
    ]
    
    for patron in patrones:
        if match := re.search(patron, texto, re.IGNORECASE):
            zona = match.group(1).strip()
            # Limpiar palabras comunes que no son parte del nombre
            palabras_a_eliminar = ['en', 'la', 'el', 'los', 'las', 'de', 'del', 'y', 'con']
            for palabra in palabras_a_eliminar:
                zona = re.sub(r'\b' + palabra + r'\b', '', zona, flags=re.IGNORECASE)
            
            # Eliminar palabras inválidas
            for palabra in palabras_invalidas:
                zona = re.sub(r'\b' + palabra + r'\b', '', zona, flags=re.IGNORECASE)
            
            zona = ' '.join(zona.split())  # Eliminar espacios múltiples
            if len(zona) > 3 and not any(palabra in zona.lower() for palabra in palabras_invalidas):
                return zona.title()  # Convertir a formato título (primera letra mayúscula)
    
    return ""

def convertir_precio_texto_a_numero(texto_precio):
    """
    Convierte un texto de precio en formato mexicano a un número.
    Ejemplos:
    $1.234.567 -> 1234567
    $1.234.567,00 -> 1234567
    $1,234,567 -> 1234567
    $1,234,567.00 -> 1234567
    """
    if not texto_precio:
        return 0.0
    
    # Limpiar el texto
    numero = texto_precio.replace('$', '').strip()
    
    try:
        # Caso especial: formato mexicano con puntos como separadores de miles
        if '.' in numero:
            # Remover la parte decimal si existe
            if ',' in numero:
                numero = numero.split(',')[0]
            # Si termina en .000, removerlo
            if numero.endswith('.000'):
                numero = numero[:-4]
            # Juntar los números separados por puntos
            partes = numero.split('.')
            # Si hay más de una parte y la última tiene 3 dígitos, es separador de miles
            if len(partes) > 1 and len(partes[-1]) == 3:
                valor = float(''.join(partes))
            else:
                # Tratar como número decimal normal
                valor = float(numero)
            return valor
        
        # Caso especial: formato con comas como separadores de miles
        if ',' in numero:
            # Remover la parte decimal si existe
            if '.' in numero:
                numero = numero.split('.')[0]
            # Si termina en ,000, removerlo
            if numero.endswith(',000'):
                numero = numero[:-4]
            # Juntar los números separados por comas
            partes = numero.split(',')
            # Si hay más de una parte y la última tiene 3 dígitos, es separador de miles
            if len(partes) > 1 and len(partes[-1]) == 3:
                valor = float(''.join(partes))
            else:
                # Tratar como número decimal normal
                valor = float(numero.replace(',', '.'))
            return valor
        
        # Si es un número simple
        return float(numero)
    except:
        return 0.0

def extraer_precio(texto, datos=None):
    """
    Extrae el precio de la propiedad con varios formatos posibles.
    Retorna un diccionario con el valor numérico y el formato para mostrar.
    """
    # Valores por defecto
    precio_default = {
        "valor": 0.0,
        "formato": "$0",
        "moneda": "MXN",
        "confianza": 0.0,
        "mensaje": "No se encontró precio",
        "fuente": "ninguna"
    }
    
    # Si tenemos datos del repositorio original, usar ese precio directamente
    if datos and isinstance(datos, dict):
        precio_original = datos.get('precio', '')
        if precio_original:
            # Limpiar el precio original
            precio_limpio = str(precio_original).replace('$', '').replace(' ', '').strip()
            # Convertir el precio a número
            try:
                # Caso 1: Formato con puntos como separadores (ej: 3.300.000)
                if precio_limpio.count('.') > 1:
                    valor = float(''.join(precio_limpio.split('.')))
                    return {
                        "valor": valor,
                        "formato": precio_original,  # Mantener el formato original exacto
                        "moneda": "MXN",
                        "confianza": 1.0,  # Máxima confianza por venir del repositorio
                        "mensaje": "Precio del repositorio original",
                        "fuente": "repositorio"
                    }
                # Caso 2: Formato con comas como separadores (ej: 3,300,000)
                elif precio_limpio.count(',') > 1:
                    valor = float(''.join(precio_limpio.split(',')))
                    return {
                        "valor": valor,
                        "formato": precio_original,
                        "moneda": "MXN",
                        "confianza": 1.0,
                        "mensaje": "Precio del repositorio original",
                        "fuente": "repositorio"
                    }
                # Caso 3: Un solo separador decimal
                elif '.' in precio_limpio:
                    valor = float(precio_limpio)
                    return {
                        "valor": valor,
                        "formato": precio_original,
                        "moneda": "MXN",
                        "confianza": 1.0,
                        "mensaje": "Precio del repositorio original",
                        "fuente": "repositorio"
                    }
                elif ',' in precio_limpio:
                    valor = float(precio_limpio.replace(',', '.'))
                    return {
                        "valor": valor,
                        "formato": precio_original,
                        "moneda": "MXN",
                        "confianza": 1.0,
                        "mensaje": "Precio del repositorio original",
                        "fuente": "repositorio"
                    }
                # Caso 4: Número simple
                else:
                    valor = float(precio_limpio)
                    return {
                        "valor": valor,
                        "formato": precio_original,
                        "moneda": "MXN",
                        "confianza": 1.0,
                        "mensaje": "Precio del repositorio original",
                        "fuente": "repositorio"
                    }
            except Exception as e:
                print(f"Error procesando precio original '{precio_original}': {str(e)}")
    
    # Si no se pudo procesar el precio del repositorio, intentar extraerlo del texto
    def extraer_matches(texto):
        """Extrae todos los posibles matches de precio del texto"""
        patrones = [
            # Millones con decimales (alta confianza)
            (r'\$?\s*(\d+(?:[.,]\d+)?)\s*millones?(?!\s*%)', 'millones', 0.95),
            (r'\$?\s*(\d+(?:[.,]\d+)?)\s*mdp(?!\s*%)', 'millones', 0.95),
            
            # Miles con decimales (alta confianza)
            (r'\$?\s*(\d+(?:[.,]\d+)?)\s*mil(?!\s*%)', 'miles', 0.9),
            
            # Formato con puntos o comas como separadores (confianza media-alta)
            (r'\$\s*([\d.,]+)(?:\.000)?(?!\s*%)', 'normal', 0.85),
            
            # Precio después de palabras clave (confianza media)
            (r'(?:precio|costo|valor|venta)\s*(?:de|:)?\s*\$?\s*([\d.,]+)', 'normal', 0.8),
            
            # Números sueltos que parecen precios (confianza baja)
            (r'(?<!\d)\$?\s*([\d.,]+)(?:\s*(?:pesos|mxn))?(?!\s*%)', 'normal', 0.7)
        ]
        
        matches = []
        for patron, tipo, confianza_base in patrones:
            for match in re.finditer(patron, texto, re.IGNORECASE):
                matches.append({
                    'texto': match.group(1),
                    'tipo': tipo,
                    'confianza_base': confianza_base,
                    'posicion': match.start()
                })
        return matches
    
    # Normalizar texto y detectar tipo de operación
    texto = normalizar_texto(texto)
    tipo_operacion = detectar_tipo_operacion(texto)
    
    # Extraer todos los posibles matches
    matches = extraer_matches(texto)
    
    # Procesar cada match y quedarnos con el mejor
    mejor_precio = None
    mejor_confianza = 0
    mejor_mensaje = None
    
    for match in matches:
        if valor := procesar_numero_mexicano(match['texto']):
            # Aplicar multiplicador según el tipo
            if match['tipo'] == 'millones':
                valor = valor * 1_000_000
            elif match['tipo'] == 'miles':
                valor = valor * 1_000
            
            es_valido, confianza_precio, mensaje = validar_precio(valor, tipo_operacion)
            if es_valido:
                confianza_total = match['confianza_base'] * confianza_precio
                
                # Ajustar confianza por posición en el texto
                if match['posicion'] < len(texto) // 2:
                    confianza_total *= 1.1  # Mayor confianza si aparece al principio
                
                if confianza_total > mejor_confianza:
                    mejor_precio = valor
                    mejor_confianza = confianza_total
                    mejor_mensaje = mensaje
    
    if mejor_precio is not None:
        return {
            "valor": mejor_precio,
            "formato": "${:,.0f}".format(mejor_precio),
            "moneda": "MXN",
            "confianza": mejor_confianza,
            "mensaje": mejor_mensaje,
            "fuente": "texto"
        }
    
    return precio_default

def detectar_tipo_operacion(texto):
    """
    Detecta el tipo de operación (Venta/Renta) basado en el texto.
    """
    texto = normalizar_texto(texto)
    
    if any(x in texto for x in ['renta', 'alquiler', '/mes', 'mensual']):
        return "Renta"
    elif any(x in texto for x in ['venta', 'se vende', 'remato']):
        return "Venta"
    
    return None

def normalizar_texto(texto):
    """
    Normaliza un texto eliminando caracteres especiales y convirtiendo a minúsculas.
    """
    if not texto or not isinstance(texto, str):
        return ""
    
    # Convertir a minúsculas
    texto = texto.lower()
    
    # Reemplazar caracteres especiales
    replacements = {
        'á': 'a', 'é': 'e', 'í': 'i', 'ó': 'o', 'ú': 'u',
        'ü': 'u', 'ñ': 'n', 'à': 'a', 'è': 'e', 'ì': 'i',
        'ò': 'o', 'ù': 'u', 'ä': 'a', 'ë': 'e', 'ï': 'i',
        'ö': 'o', 'ü': 'u'
    }
    
    for old, new in replacements.items():
        texto = texto.replace(old, new)
    
    # Normalizar caracteres especiales de medidas
    texto = texto.replace('²', '2')  # Normalizar el superíndice ²
    texto = texto.replace('m2', 'm²')  # Normalizar m2 a m²
    texto = texto.replace('mt2', 'm²')  # Normalizar mt2 a m²
    texto = texto.replace('mts2', 'm²')  # Normalizar mts2 a m²
    
    return texto

def procesar_texto(texto, datos):
    """Procesa el texto para extraer características"""
    if not texto or not isinstance(texto, str):
        texto = ""
    
    caracteristicas = {
        'recamaras': None,
        'banos': None,
        'niveles': None,
        'es_un_nivel': False,
        'superficie_m2': None,
        'construccion_m2': None,
        'recamara_pb': False,
        'cisterna': False,
        'capacidad_cisterna': None,
        'apto_discapacitados': False,
        'estacionamientos': None,
        'edad': None
    }
    
    texto = normalizar_texto(texto)
    
    # Extraer superficie y construcción
    medidas = extraer_superficie_y_construccion(texto)
    caracteristicas['superficie_m2'] = medidas['superficie_m2']
    caracteristicas['construccion_m2'] = medidas['construccion_m2']
    
    # Extraer recámaras
    patrones_recamaras = [
        r'(\d+)\s*(?:recamaras?|recámaras?|rec|habitaciones?|dormitorios?)',
        r'(?:recamaras?|recámaras?|rec|habitaciones?|dormitorios?)\s*(?::|con)?\s*(\d+)'
    ]
    for patron in patrones_recamaras:
        if match := re.search(patron, texto):
            try:
                caracteristicas['recamaras'] = int(match.group(1))
                break
            except:
                continue
    
    # Detectar niveles y si es de un nivel
    patrones_un_nivel = [
        r'(?:casa|propiedad|inmueble)\s*(?:nueva\s+)?(?:en\s+)?(?:venta\s+)?(?:de|en|con)\s*(?:un|1)\s*nivel',
        r'(?:de|en|con)\s*(?:un|1)\s*nivel',
        r'un\s*nivel',
        r'una\s*planta',
        r'planta\s*baja'
    ]
    
    if any(re.search(patron, texto, re.IGNORECASE) for patron in patrones_un_nivel):
        caracteristicas['es_un_nivel'] = True
        caracteristicas['niveles'] = 1
    else:
        # Buscar otros números de niveles
        patrones_niveles = [
            r'(\d+)\s*(?:niveles?|pisos?)',
            r'(?:niveles?|pisos?)\s*(?::|con)?\s*(\d+)'
        ]
        for patron in patrones_niveles:
            if match := re.search(patron, texto):
                try:
                    caracteristicas['niveles'] = int(match.group(1))
                    break
                except:
                    continue
    
    # Extraer baños
    total_banos = 0
    banos_recamaras = 0
    banos_servicio = 0
    banos_visitas = 0
    
    # Detectar baños de recámaras
    if caracteristicas['recamaras'] and re.search(r'cada\s*(?:uno|una|recamara|habitacion)\s*con\s*(?:su\s*)?(?:propio\s*)?baño', texto):
        banos_recamaras = caracteristicas['recamaras']
    
    # Detectar baño de servicio
    if re.search(r'(?:cuarto|habitacion|area)\s*(?:de)?\s*servicio\s*con\s*baño', texto):
        banos_servicio = 1
    
    # Detectar baño de visitas
    if re.search(r'baño\s*(?:de)?\s*visitas?', texto):
        banos_visitas = 1
    
    # Sumar todos los baños encontrados
    total_banos = banos_recamaras + banos_servicio + banos_visitas
    
    # Si no se encontraron baños por el método detallado, buscar número total
    if total_banos == 0:
        patrones_banos = [
            r'(?<!\d)(\d+)\s*(?:baños?|banos?|wc)(?!\s*(?:mil|millones|mdp|m2|m3|litros|metros))',
            r'(?:baños?|banos?|wc)\s*(?::|con)?\s*(?<!\d)(\d+)(?!\s*(?:mil|millones|mdp|m2|m3|litros|metros))'
        ]
        for patron in patrones_banos:
            if match := re.search(patron, texto):
                try:
                    num = int(match.group(1))
                    if 0 < num <= 10:  # Validación para números razonables
                        total_banos = num
                        break
                except:
                    continue
    
    if total_banos > 0:
        caracteristicas['banos'] = total_banos
    
    # Detectar recámara en planta baja
    if any(x in texto for x in ['recamara en pb', 'recámara en planta baja', 'dormitorio en pb']):
        caracteristicas['recamara_pb'] = True
    
    # Detectar cisterna y su capacidad
    if 'cisterna' in texto:
        caracteristicas['cisterna'] = True
        # Buscar capacidad de la cisterna
        patrones_cisterna = [
            r'cisterna\s*(?:de)?\s*(\d+)\s*(?:m3|metros?3?|litros?)',
            r'cisterna\s*(?:de)?\s*(\d+)(?:,\d+)?\s*(?:m3|metros?3?|litros?)',
            r'cisterna\s*(?:de)?\s*(\d+)\s*mil\s*(?:m3|metros?3?|litros?)'
        ]
        for patron in patrones_cisterna:
            if match := re.search(patron, texto):
                try:
                    capacidad = match.group(1)
                    if 'mil' in match.group():
                        capacidad = int(capacidad) * 1000
                    else:
                        capacidad = int(capacidad)
                    caracteristicas['capacidad_cisterna'] = capacidad
                    break
                except:
                    continue
    
    # Extraer estacionamientos
    caracteristicas['estacionamientos'] = extraer_estacionamientos(texto)
    
    # Extraer zona
    zona = extraer_zona(texto)
    
    # Extraer precio y tipo de operación
    precio_info = extraer_precio(texto, datos)
    tipo_operacion = detectar_tipo_operacion(texto) or "Desconocido"
    
    # Determinar tipo de propiedad
    tipo_propiedad = "Otro"
    tipos = {
        'Casa': ['casa', 'residencia', 'chalet'],
        'Departamento': ['departamento', 'depto', 'dpto', 'apartamento'],
        'Terreno': ['terreno', 'lote', 'predio'],
        'Local': ['local', 'comercial'],
        'Oficina': ['oficina', 'despacho'],
        'Bodega': ['bodega', 'almacén']
    }
    
    for tipo, palabras in tipos.items():
        if any(palabra in texto for palabra in palabras):
            tipo_propiedad = tipo
            break
    
    # Obtener datos de ubicación del objeto original si están disponibles
    ubicacion = {
        "colonia": datos.get('ubicacion', {}).get('colonia', ''),
        "calle": datos.get('ubicacion', {}).get('calle', ''),
        "estado": datos.get('ubicacion', {}).get('estado', 'Morelos'),
        "ciudad": datos.get('ubicacion', {}).get('ciudad', 'Cuernavaca'),
        "referencias": datos.get('ubicacion', {}).get('referencias', ''),
        "zona": zona or extraer_fraccionamiento(texto)  # Intentar extraer fraccionamiento si no hay zona
    }
    
    return {
        "id": datos.get('id', ''),
        "link": datos.get('link', ''),
        "descripcion": texto,
        "ubicacion": ubicacion,
        "propiedad": {
            "tipo_propiedad": tipo_propiedad,
            "precio": precio_info,
            "tipo_operacion": tipo_operacion
        },
        "descripcion_detallada": {
            "caracteristicas": caracteristicas,
            "amenidades": extraer_amenidades(texto),
            "legal": extraer_legal(texto)
        },
        "metadata": {
            "fecha_extraccion": datos.get('fecha_extraccion', datetime.now().isoformat()),
            "fecha_procesamiento": datetime.now().isoformat()
        }
    }

def extraer_superficie_y_construccion(texto):
    """
    Extrae la superficie total y construida del texto.
    """
    resultado = {
        "superficie_m2": None,
        "construccion_m2": None
    }
    
    # Patrones para superficie total
    patrones_superficie = [
        # Patrones básicos
        r'(?:superficie|terreno|lote)(?:\s+de)?:?\s*(\d+)\s*(?:m²|m2|metros?|mt2|mts2?)',
        r'(\d+)\s*(?:m²|m2|metros?|mt2|mts2?)\s*(?:de\s*terreno|superficie)',
        
        # Patrones con dimensiones
        r'(\d+)\s*x\s*(\d+)\s*(?:m²|m2|metros?)?',
        r'(\d+)\s*por\s*(\d+)\s*(?:m²|m2|metros?)?',
        
        # Patrones con punto decimal
        r'(?:superficie|terreno|lote)(?:\s+de)?:?\s*(\d+\.\d+)\s*(?:m²|m2|metros?|mt2|mts2?)',
        r'(\d+\.\d+)\s*(?:m²|m2|metros?|mt2|mts2?)\s*(?:de\s*terreno|superficie)'
    ]
    
    # Patrones para construcción
    patrones_construccion = [
        # Patrones básicos
        r'(?:construccion|construcción)(?:\s+de)?:?\s*(\d+)\s*(?:m²|m2|metros?|mt2|mts2?)',
        r'(\d+)\s*(?:m²|m2|metros?|mt2|mts2?)\s*(?:de\s*construccion|de\s*construcción)',
        
        # Patrones con punto decimal
        r'(?:construccion|construcción)(?:\s+de)?:?\s*(\d+\.\d+)\s*(?:m²|m2|metros?|mt2|mts2?)',
        r'(\d+\.\d+)\s*(?:m²|m2|metros?|mt2|mts2?)\s*(?:de\s*construccion|de\s*construcción)'
    ]
    
    # Buscar superficie
    for patron in patrones_superficie:
        if match := re.search(patron, texto, re.IGNORECASE):
            try:
                # Si es un patrón de dimensiones (largo x ancho)
                if 'x' in patron or 'por' in patron:
                    largo = float(match.group(1))
                    ancho = float(match.group(2))
                    resultado["superficie_m2"] = int(largo * ancho)
                else:
                    resultado["superficie_m2"] = int(float(match.group(1)))
                break
            except:
                continue
    
    # Buscar construcción
    for patron in patrones_construccion:
        if match := re.search(patron, texto, re.IGNORECASE):
            try:
                resultado["construccion_m2"] = int(float(match.group(1)))
                break
            except:
                continue
    
    return resultado

def extraer_amenidades(texto):
    """
    Extrae las amenidades mencionadas en el texto.
    """
    amenidades = []
    
    # Mapeo de amenidades y sus palabras clave
    mapeo_amenidades = {
        'seguridad': ['vigilancia', 'seguridad', 'caseta', 'privada', 'vigilante', 'seguridad 24/7', 'control de acceso'],
        'alberca': ['alberca', 'piscina', 'pool', 'chapoteadero', 'area de nado'],
        'jardin': ['jardin', 'jardín', 'área verde', 'area verde', 'jardinado', 'jardinada'],
        'terraza': ['terraza', 'balcón', 'balcon', 'deck', 'patio'],
        'estacionamiento': ['cochera', 'estacionamiento', 'parking', 'garage', 'garaje', 'cajon', 'lugar de auto'],
        'bodega': ['bodega', 'storage', 'cuarto de servicio', 'almacen'],
        'roof_garden': ['roof garden', 'rooftop', 'terraza en azotea', 'sky garden', 'azotea verde'],
        'gimnasio': ['gym', 'gimnasio', 'area de ejercicio', 'área de ejercicio'],
        'area_comun': ['área común', 'area comun', 'areas comunes', 'áreas comunes', 'salon de usos multiples'],
        'juegos_infantiles': ['juegos infantiles', 'área de juegos', 'area de juegos', 'playground', 'parque infantil'],
        'salon_eventos': ['salón', 'salon', 'eventos', 'fiestas', 'salon de usos multiples'],
        'elevador': ['elevador', 'ascensor', 'lift'],
        'aire_acondicionado': ['aire acondicionado', 'a/c', 'clima', 'minisplit', 'climatizacion'],
        'amueblado': ['amueblado', 'equipado', 'línea blanca', 'linea blanca', 'cocina equipada'],
        'cocina_integral': ['cocina integral', 'cocina equipada', 'cocina completa'],
        'calentador_solar': ['calentador solar', 'paneles solares', 'energia solar'],
        'cisterna': ['cisterna', 'aljibe', 'almacenamiento de agua'],
        'internet': ['internet', 'wifi', 'conexion a internet'],
        'gas_natural': ['gas natural', 'gas estacionario'],
        'hidroneumatico': ['hidroneumatico', 'hidro', 'bomba de agua', 'presurizador'],
        'tinaco': ['tinaco', 'deposito de agua'],
        'closets': ['closets', 'closet', 'vestidor', 'walk in closet'],
        'bar': ['bar', 'cantina', 'cava'],
        'estudio': ['estudio', 'oficina', 'biblioteca', 'home office']
    }
    
    texto = normalizar_texto(texto)
    
    # Buscar cada amenidad en el texto
    for amenidad, palabras_clave in mapeo_amenidades.items():
        if any(palabra in texto for palabra in palabras_clave):
            amenidades.append(amenidad)
    
    return sorted(amenidades)  # Ordenar alfabéticamente para consistencia

def extraer_legal(texto):
    """
    Extrae información legal y formas de pago aceptadas.
    """
    resultado = {
        "escrituras": False,
        "cesion_derechos": False,
        "creditos_disponibles": [],
        "estado_juridico": "regular"
    }
    
    texto = normalizar_texto(texto)
    
    # Verificar escrituras
    if any(x in texto for x in ['escrituras', 'escriturada', 'titulo de propiedad']):
        resultado["escrituras"] = True
    
    # Verificar cesión de derechos
    if any(x in texto for x in ['cesion de derechos', 'cesión de derechos', 'traspaso']):
        resultado["cesion_derechos"] = True
        resultado["estado_juridico"] = "cesion_derechos"
    
    # Verificar créditos disponibles
    creditos = {
        'infonavit': ['infonavit', 'info'],
        'fovissste': ['fovissste', 'fovi'],
        'bancario': ['credito bancario', 'banco', 'hipoteca'],
        'contado': ['contado', 'efectivo'],
        'financiamiento': ['financiamiento', 'credito']
    }
    
    for credito, palabras in creditos.items():
        if any(palabra in texto for palabra in palabras):
            resultado["creditos_disponibles"].append(credito)
    
    # Verificar estado jurídico
    if any(x in texto for x in ['intestado', 'intestada', 'juicio']):
        resultado["estado_juridico"] = "irregular"
    elif any(x in texto for x in ['embargo', 'embargada']):
        resultado["estado_juridico"] = "embargo"
    
    return resultado

def extraer_estacionamientos(texto):
    """
    Extrae el número de estacionamientos mencionados en el texto.
    """
    texto = normalizar_texto(texto)
    
    # Patrones para estacionamientos
    patrones = [
        # Patrones numéricos explícitos
        r'(?:garaje|garage|estacionamiento|cochera)\s*(?:para|con|de)?\s*(\d+)\s*(?:autos?|carros?|coches?|vehiculos?)',
        r'(\d+)\s*(?:autos?|carros?|coches?|vehiculos?)\s*(?:en)?\s*(?:garaje|garage|estacionamiento|cochera)',
        r'(\d+)\s*(?:estacionamientos?|cajone?s?|lugares?\s*(?:de\s*)?(?:estacionamiento|auto)|cocheras?)',
        r'(?:estacionamiento|cajon|lugar|cochera)(?:es)?\s*(?:para|con|de)?\s*(\d+)(?:\s*autos?)?',
        
        # Patrones con números escritos
        r'(?:un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s*(?:estacionamientos?|cajone?s?|lugares?\s*(?:de\s*)?(?:estacionamiento|auto)|cocheras?)',
        
        # Patrones específicos
        r'estacionamiento\s*(?:para|con|de)\s*(?:un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s*(?:auto|carro|coche|vehiculo)',
        r'cochera\s*(?:para|con|de)\s*(?:un|uno|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez)\s*(?:auto|carro|coche|vehiculo)'
    ]
    
    # Mapeo de números escritos a dígitos
    numeros_escritos = {
        'un': 1, 'uno': 1, 'dos': 2, 'tres': 3, 'cuatro': 4,
        'cinco': 5, 'seis': 6, 'siete': 7, 'ocho': 8,
        'nueve': 9, 'diez': 10
    }
    
    for patron in patrones:
        if match := re.search(patron, texto, re.IGNORECASE):
            try:
                # Si es un número escrito
                numero = match.group(1) if match.group(1).isdigit() else match.group(0)
                for num_escrito, valor in numeros_escritos.items():
                    if num_escrito in numero.lower():
                        return valor
                # Si es un número en dígitos
                num = int(match.group(1))
                if 0 < num <= 10:  # Validación para evitar confusiones con porcentajes
                    return num
            except:
                continue
    
    # Si no se encontró un número específico pero hay menciones de estacionamiento
    if any(palabra in texto for palabra in ['estacionamiento', 'cochera', 'garage', 'cajon']):
        return 1
    
    return None

def extraer_fraccionamiento(texto):
    """
    Extrae el nombre del fraccionamiento si está mencionado.
    """
    texto = normalizar_texto(texto)
    
    # Patrones para fraccionamientos
    patrones = [
        r'(?:fraccionamiento|fracc|coto|cluster|privada|residencial)\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:con|cerca|junto|proximo|sobre|por|entre|cuernavaca|morelos))',
        r'(?:en|dentro\s+de)\s+([A-Za-zÁ-Úá-úñÑ\s]+?)(?:\s+(?:con|cerca|junto|proximo|sobre|por|entre|cuernavaca|morelos))'
    ]
    
    # Palabras que no deben ser parte del nombre
    palabras_invalidas = [
        'venta', 'renta', 'precio', 'cerca', 'junto', 'proximo', 'minutos',
        'sobre', 'entre', 'casa', 'depto', 'departamento', 'terreno',
        'infonavit', 'credito', 'banco', 'recurso', 'propio', 'acepto',
        'aceptamos', 'contado', 'sala', 'comedor', 'cocina', 'recamara',
        'recamaras', 'bano', 'banos', 'estacionamiento', 'garage',
        'cuernavaca', 'morelos', 'exclusivo', 'privado', 'seguridad'
    ]
    
    for patron in patrones:
        if match := re.search(patron, texto, re.IGNORECASE):
            nombre = match.group(1).strip()
            # Limpiar palabras comunes
            palabras_a_eliminar = ['en', 'la', 'el', 'los', 'las', 'de', 'del', 'y', 'con']
            for palabra in palabras_a_eliminar:
                nombre = re.sub(r'\b' + palabra + r'\b', '', nombre, flags=re.IGNORECASE)
            
            # Eliminar palabras inválidas
            for palabra in palabras_invalidas:
                nombre = re.sub(r'\b' + palabra + r'\b', '', nombre, flags=re.IGNORECASE)
            
            nombre = ' '.join(nombre.split())  # Eliminar espacios múltiples
            if len(nombre) > 3 and not any(palabra in nombre.lower() for palabra in palabras_invalidas):
                return nombre.title()
    
    # Buscar nombres específicos de fraccionamientos conocidos
    fraccionamientos_conocidos = [
        'kloster sumiya', 'sumiya', 'tabachines', 'delicias',
        'rancho cortes', 'vista hermosa', 'palmira', 'lomas de cocoyoc',
        'burgos', 'paraiso country club', 'real de tetela'
    ]
    
    for fracc in fraccionamientos_conocidos:
        if fracc in texto.lower():
            return fracc.title()
    
    return ""

def procesar_numero_mexicano(numero):
    """
    Procesa un número en formato mexicano con manejo especial de separadores.
    Retorna el valor numérico o None si no se puede procesar.
    """
    try:
        # Limpiar el texto
        numero = numero.replace(' ', '').replace('$', '').strip()
        
        # Si no hay números, retornar None
        if not any(c.isdigit() for c in numero):
            return None
            
        # Detectar si es un formato con millones
        if 'millones' in numero.lower() or 'mdp' in numero.lower():
            base = re.search(r'(\d+(?:[.,]\d+)?)', numero)
            if base:
                return float(base.group(1).replace(',', '.')) * 1_000_000
        
        # Detectar si es un formato con miles
        if 'mil' in numero.lower():
            base = re.search(r'(\d+(?:[.,]\d+)?)', numero)
            if base:
                return float(base.group(1).replace(',', '.')) * 1_000
        
        # Remover sufijos comunes
        numero = numero.replace('.000', '').replace(',000', '')
        
        # Contar separadores
        puntos = numero.count('.')
        comas = numero.count(',')
        
        # Caso 1: Solo puntos como separadores (ej: 1.234.567)
        if puntos > 0 and comas == 0:
            partes = numero.split('.')
            if len(partes) >= 2 and all(len(parte) == 3 for parte in partes[1:]):
                return float(''.join(partes))
            
        # Caso 2: Solo comas como separadores (ej: 1,234,567)
        if comas > 0 and puntos == 0:
            partes = numero.split(',')
            if len(partes) >= 2 and all(len(parte) == 3 for parte in partes[1:]):
                return float(''.join(partes))
        
        # Caso 3: Ambos separadores (ej: 1.234,56 o 1,234.56)
        if puntos > 0 and comas > 0:
            # El último separador es el decimal
            if numero.rindex('.') > numero.rindex(','):
                # 1,234.56 formato
                numero = numero.replace(',', '')
            else:
                # 1.234,56 formato
                numero = numero.replace('.', '').replace(',', '.')
            return float(numero)
        
        # Caso 4: Número simple sin separadores
        if puntos == 0 and comas == 0:
            return float(numero)
        
        # Caso 5: Un solo separador
        if (puntos == 1 and comas == 0) or (comas == 1 and puntos == 0):
            sep = '.' if puntos == 1 else ','
            partes = numero.split(sep)
            if len(partes) == 2:
                # Si la parte decimal tiene 3 dígitos y el número es grande,
                # probablemente es un separador de miles
                if len(partes[1]) == 3 and float(partes[0]) >= 100:
                    return float(''.join(partes))
                # Si no, tratar como decimal normal
                return float(numero.replace(',', '.'))
        
        # Si llegamos aquí, intentar una última conversión simple
        return float(numero.replace(',', '').replace('.', ''))
        
    except Exception as e:
        print(f"Error procesando número '{numero}': {str(e)}")
        return None

def validar_precio(valor, tipo_operacion=None):
    """
    Valida que el precio esté en un rango razonable según el tipo de operación.
    Retorna (es_valido, confianza, mensaje_error).
    """
    if not valor or valor <= 0:
        return False, 0.0, "Precio inválido o cero"
    
    if valor > 100_000_000:
        return False, 0.0, "Precio excede el límite máximo de 100 millones"
    
    confianza = 0.8  # Confianza base
    mensaje = None
    
    # Rangos por tipo de operación
    rangos = {
        "Venta": {
            "min": 100_000,
            "max": 50_000_000,
            "optimo_min": 500_000,
            "optimo_max": 20_000_000
        },
        "Renta": {
            "min": 1_000,
            "max": 100_000,
            "optimo_min": 3_000,
            "optimo_max": 50_000
        }
    }
    
    if tipo_operacion in rangos:
        rango = rangos[tipo_operacion]
        
        # Verificar límites estrictos
        if valor < rango["min"]:
            return False, 0.0, f"Precio muy bajo para {tipo_operacion}"
        if valor > rango["max"]:
            return False, 0.0, f"Precio muy alto para {tipo_operacion}"
        
        # Ajustar confianza según el rango óptimo
        if rango["optimo_min"] <= valor <= rango["optimo_max"]:
            confianza = 0.9
        else:
            confianza = 0.7
            mensaje = "Precio fuera del rango óptimo"
    
    # Ajustar confianza por números redondos
    if valor % 1_000_000 == 0:
        confianza *= 0.95  # Menos confianza en números muy redondos
        if not mensaje:
            mensaje = "Precio en millones exactos"
    elif valor % 100_000 == 0:
        confianza *= 0.98
        if not mensaje:
            mensaje = "Precio en cientos de miles exactos"
    elif valor % 1_000 == 0:
        confianza *= 0.99
        if not mensaje:
            mensaje = "Precio en miles exactos"
    
    # Ajustar confianza por magnitud del precio
    if valor >= 10_000_000:
        confianza *= 0.95  # Menor confianza en precios muy altos
        if not mensaje:
            mensaje = "Precio muy alto"
    elif valor <= 200_000:
        confianza *= 0.95  # Menor confianza en precios muy bajos
        if not mensaje:
            mensaje = "Precio muy bajo"
    
    return True, confianza, mensaje

if __name__ == '__main__':
    procesar_datos_crudos() 